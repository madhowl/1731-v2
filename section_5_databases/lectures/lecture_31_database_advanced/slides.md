# Лекция 31: Работа с базами данных - продвинутый уровень

## Оптимизация запросов, транзакции, индексы

### Цель лекции:
- Изучить продвинутые техники работы с базами данных
- Освоить оптимизацию SQL-запросов
- Понять работу транзакций
- Научиться использовать индексы эффективно

### План лекции:
1. Оптимизация запросов
2. Транзакции
3. Индексы
4. Пул соединений
5. Обработка больших объемов данных

---

## 1. Оптимизация запросов

Оптимизация запросов — процесс улучшения производительности SQL-запросов путем изменения их структуры или настройки базы данных.

### Основные проблемы производительности:
- **Неэффективные JOIN'ы** - слишком много соединений таблиц
- **Отсутствие индексов** - медленные операции поиска
- **Неправильная фильтрация** - фильтрация после загрузки лишних данных
- **Сложные подзапросы** - выполнение подзапросов для каждой строки

### Техники оптимизации:
1. **Использование индексов** - для ускорения поиска
2. **Ограничение результатов** - использование LIMIT
3. **Правильная фильтрация** - сначала фильтруем, потом соединяем
4. **Избегание функций в WHERE** - они мешают использованию индексов

### Примеры плохих и хороших запросов:

```sql
-- Плохо: функция в WHERE мешает индексу
SELECT * FROM users WHERE YEAR(birth_date) = 1990;

-- Хорошо: диапазон дат позволяет использовать индекс
SELECT * FROM users 
WHERE birth_date >= '1990-01-01' AND birth_date < '1991-01-01';

-- Плохо: подзапрос выполняется для каждой строки
SELECT u.name, 
       (SELECT COUNT(*) FROM orders WHERE user_id = u.id) as order_count
FROM users u;

-- Хорошо: JOIN более эффективен
SELECT u.name, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id;
```

### Анализ выполнения запросов:
```sql
-- PostgreSQL
EXPLAIN ANALYZE SELECT * FROM users WHERE age > 25;

-- MySQL
EXPLAIN FORMAT=JSON SELECT * FROM users WHERE age > 25;

-- SQLite
EXPLAIN QUERY PLAN SELECT * FROM users WHERE age > 25;
```

### Плохие практики:
- Использование `SELECT *` когда нужны только определенные поля
- Отсутствие ограничений в запросах, возвращающих много данных
- Неправильное использование подзапросов
- Отсутствие индексов на часто используемых полях

---

## 2. Транзакции

Транзакция — последовательность операций с базой данных, рассматриваемая как единое целое (все операции выполняются успешно или ни одна не выполняется).

### ACID-свойства:
- **A**tomicity (Атомарность) - все или ничего
- **C**onsistency (Согласованность) - транзакция переводит БД из одного согласованного состояния в другое
- **I**solation (Изолированность) - транзакции не влияют друг на друга
- **D**urability (Долговечность) - результаты выполненной транзакции сохраняются

### Уровни изоляции:
1. **READ UNCOMMITTED** - самый низкий уровень, может читать "грязные" данные
2. **READ COMMITTED** - стандартный уровень для большинства СУБД
3. **REPEATABLE READ** - уровень по умолчанию в MySQL
4. **SERIALIZABLE** - самый высокий уровень, полная изоляция

### Пример использования транзакции:
```python
import sqlite3

conn = sqlite3.connect('bank.db')
try:
    conn.execute('BEGIN')
    
    # Снятие денег со счета
    conn.execute("UPDATE accounts SET balance = balance - ? WHERE id = ?", (100, 1))
    
    # Зачисление денег на другой счет
    conn.execute("UPDATE accounts SET balance = balance + ? WHERE id = ?", (100, 2))
    
    conn.commit()  # Подтверждение транзакции
    print("Перевод успешно выполнен")
except Exception as e:
    conn.rollback()  # Откат транзакции
    print(f"Ошибка транзакции: {e}")
finally:
    conn.close()
```

### Транзакции в SQLAlchemy:
```python
from sqlalchemy.exc import IntegrityError

try:
    # Начало транзакции
    session.begin()
    
    # Выполнение операций
    user = User(name="Иван", email="ivan@example.com")
    session.add(user)
    session.flush()  # Получение ID без коммита
    
    profile = UserProfile(user_id=user.id, bio="Новый пользователь")
    session.add(profile)
    
    session.commit()  # Подтверждение транзакции
except IntegrityError:
    session.rollback()  # Откат транзакции
    print("Ошибка целостности данных")
```

### Проблемы параллельного доступа:
- **Потерянное обновление** - два процесса изменяют одно значение
- **"Грязное" чтение** - чтение неподтвержденных изменений
- **Неповторяющееся чтение** - разные результаты при повторном чтении
- **Фантомное чтение** - появление новых строк между запросами

---

## 3. Индексы

Индекс — структура данных, позволяющая быстро находить записи в таблице по значению одного или нескольких полей.

### Типы индексов:
1. **B-tree** - по умолчанию, подходит для равенства и диапазонов
2. **Hash** - для поиска по точному совпадению
3. **Bitmap** - для полей с малым количеством уникальных значений
4. **Full-text** - для поиска по тексту
5. **Spatial** - для географических данных

### Создание индексов:
```sql
-- Простой индекс
CREATE INDEX idx_users_email ON users(email);

-- Композитный индекс (несколько полей)
CREATE INDEX idx_users_name_age ON users(name, age);

-- Уникальный индекс
CREATE UNIQUE INDEX idx_users_username ON users(username);

-- Индекс с условиями (частичный индекс)
CREATE INDEX idx_active_users ON users(email) WHERE active = true;
```

### Когда использовать индексы:
- На полях, используемых в WHERE
- На полях, используемых в JOIN
- На полях, используемых в ORDER BY
- На полях с высокой селективностью (много уникальных значений)

### Когда НЕ использовать индексы:
- На часто изменяемых таблицах (замедляет INSERT/UPDATE/DELETE)
- На полях с низкой селективностью (например, поле "пол")
- На маленьких таблицах (поиск может быть быстрее без индекса)

### Оптимизация индексов:
```sql
-- Проверка использования индексов
EXPLAIN SELECT * FROM users WHERE email = 'user@example.com';

-- Удаление неиспользуемых индексов
DROP INDEX idx_users_old_field;

-- Переиндексация таблицы (для улучшения производительности)
REINDEX TABLE users;  -- PostgreSQL
OPTIMIZE TABLE users;  -- MySQL
```

---

## 4. Пул соединений

Пул соединений — кэш соединений с базой данных, которые могут повторно использоваться.

### Преимущества пула соединений:
- **Снижение накладных расходов** - не нужно создавать новое соединение каждый раз
- **Ограничение нагрузки** - ограничение количества одновременных соединений
- **Управление ресурсами** - автоматическое закрытие неиспользуемых соединений

### Настройка пула в SQLAlchemy:
```python
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

# Создание engine с настроенным пулом
engine = create_engine(
    'postgresql://user:password@localhost/dbname',
    poolclass=QueuePool,
    pool_size=10,           # Размер пула
    max_overflow=20,        # Максимальное количество дополнительных соединений
    pool_recycle=3600,      # Время жизни соединения (в секундах)
    pool_pre_ping=True      # Проверка соединения перед использованием
)
```

### Пример использования:
```python
from sqlalchemy.orm import sessionmaker

# Создание фабрики сессий с пулом
Session = sessionmaker(bind=engine)

# Использование сессии
def get_user(user_id):
    session = Session()
    try:
        user = session.query(User).filter(User.id == user_id).first()
        return user
    finally:
        session.close()  # Возврат соединения в пул
```

---

## 5. Обработка больших объемов данных

### Пакетная обработка:
```python
def batch_process_users(batch_size=1000):
    offset = 0
    while True:
        users = session.query(User).offset(offset).limit(batch_size).all()
        if not users:
            break
            
        # Обработка пакета
        for user in users:
            # Обновление данных
            user.processed = True
        
        # Сохранение изменений
        session.commit()
        offset += batch_size
```

### Использование курсоров:
```python
# Для очень больших наборов данных
result = session.execute(text("SELECT * FROM large_table")).stream()
for row in result:
    # Обработка одной строки
    process_row(row)
```

### Оптимизация для больших таблиц:
- Использование партицирования таблиц
- Правильное планирование индексов
- Асинхронные запросы
- Использование материализованных представлений