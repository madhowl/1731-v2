# Лекция 32: Технологии хранения данных

## Введение в NoSQL, кэширование

### Цель лекции:
- Познакомиться с NoSQL базами данных
- Изучить основные типы NoSQL решений
- Освоить принципы кэширования данных
- Понять области применения различных технологий хранения

### План лекции:
1. Введение в NoSQL
2. Типы NoSQL баз данных
3. Кэширование данных
4. Сравнение SQL и NoSQL
5. Выбор технологии хранения

---

## 1. Введение в NoSQL

NoSQL (Not Only SQL) — подход к хранению данных, отличный от традиционных реляционных баз данных. Появился для решения проблем масштабируемости и гибкости.

### Причины появления NoSQL:
- **Большие объемы данных** - невозможность хранить в одной реляционной БД
- **Высокая доступность** - необходимость работы системы 24/7
- **Горизонтальное масштабирование** - распределение данных по нескольким серверам
- **Гибкая схема данных** - возможность изменения структуры без остановки системы

### Проблемы, решаемые NoSQL:
- **Масштабируемость** - способность системы справляться с ростом нагрузки
- **Производительность** - быстрый доступ к данным
- **Адаптивность** - гибкость структуры данных
- **Стоимость** - использование недорогих аппаратных решений

### CAP теорема:
В распределенной системе хранения данных можно обеспечить только 2 из 3 свойств:
- **Consistency (Согласованность)** - все узлы видят одинаковые данные
- **Availability (Доступность)** - каждый запрос получает ответ
- **Partition tolerance (Устойчивость к разделению)** - система продолжает работать при потере сообщений

### BASE против ACID:
- **ACID** (традиционные SQL): Atomicity, Consistency, Isolation, Durability
- **BASE** (NoSQL): Basically Available, Soft state, Eventually consistent

---

## 2. Типы NoSQL баз данных

### 2.1 Ключ-значение (Key-Value)
- **Примеры**: Redis, Amazon DynamoDB, Riak
- **Преимущества**: простота, высокая производительность, масштабируемость
- **Недостатки**: ограниченные возможности запросов
- **Применение**: кэширование, сессии пользователей, конфигурации

```python
# Пример работы с Redis
import redis

r = redis.Redis(host='localhost', port=6379, db=0)

# Сохранение данных
r.set('user:123', '{"name": "Иван", "email": "ivan@example.com"}')

# Получение данных
user_data = r.get('user:123')
```

### 2.2 Документоориентированные
- **Примеры**: MongoDB, CouchDB, Amazon DocumentDB
- **Преимущества**: гибкая схема, вложенные структуры, богатые запросы
- **Недостатки**: сложность join операций
- **Применение**: CMS, каталоги товаров, пользовательские профили

```python
# Пример документа в MongoDB
{
  "_id": ObjectId("..."),
  "name": "Иван Иванов",
  "email": "ivan@example.com",
  "orders": [
    {
      "id": "order_123",
      "date": "2023-01-01",
      "items": [
        {"product": "iPhone", "price": 70000}
      ]
    }
  ],
  "preferences": {
    "language": "ru",
    "theme": "dark"
  }
}
```

### 2.3 Колоночные (Column-family)
- **Примеры**: Cassandra, HBase, Amazon SimpleDB
- **Преимущества**: высокая производительность при чтении/записи, горизонтальное масштабирование
- **Недостатки**: сложность в использовании, специфическая модель данных
- **Применение**: аналитика, IoT данные, временные ряды

### 2.4 Графовые
- **Примеры**: Neo4j, Amazon Neptune, ArangoDB
- **Преимущества**: эффективная обработка связанных данных
- **Недостатки**: сложность для простых случаев
- **Применение**: социальные сети, рекомендательные системы, маршрутизация

```python
# Пример запроса в Neo4j (Cypher)
"""
MATCH (person:Person)-[:FRIEND]->(friend:Person)
WHERE person.name = 'Иван'
RETURN friend.name
"""
```

---

## 3. Кэширование данных

Кэширование — хранение часто используемых данных в быстрой памяти для ускорения доступа.

### Цели кэширования:
- **Ускорение доступа** - быстрый доступ к часто запрашиваемым данным
- **Снижение нагрузки** - уменьшение количества обращений к основной БД
- **Повышение доступности** - возможность работы при отказе основного источника

### Типы кэшей:
1. **Клиентский кэш** - в браузере или мобильном приложении
2. **Кэш приложений** - в памяти приложения
3. **Серверный кэш** - отдельный сервер кэширования (Redis, Memcached)
4. **CDN кэш** - для статических ресурсов

### Стратегии кэширования:
1. **Cache-Aside (Lazy Loading)**:
   - Приложение проверяет кэш
   - Если данных нет, загружает из БД и сохраняет в кэш
   - Самое распространенное решение

```python
import redis

cache = redis.Redis()

def get_user(user_id):
    # Проверяем кэш
    cached_user = cache.get(f"user:{user_id}")
    if cached_user:
        return json.loads(cached_user)
    
    # Загружаем из БД
    user = database.get_user(user_id)
    
    # Сохраняем в кэш на 1 час
    cache.setex(f"user:{user_id}", 3600, json.dumps(user))
    
    return user
```

2. **Read-Through**:
   - Приложение всегда обращается к кэшу
   - Кэш сам загружает данные из БД при необходимости

3. **Write-Through**:
   - Данные записываются одновременно в кэш и БД
   - Гарантия актуальности данных

4. **Write-Behind (Write-Back)**:
   - Данные сначала записываются в кэш
   - Позже асинхронно записываются в БД

### Алгоритмы вытеснения:
- **LRU (Least Recently Used)** - вытесняются давно неиспользуемые
- **LFU (Least Frequently Used)** - вытесняются редко используемые
- **FIFO (First In, First Out)** - вытесняются самые старые

### Пример кэширования в Python:
```python
from functools import lru_cache
import time

@lru_cache(maxsize=128)
def expensive_function(n):
    # Имитация долгой операции
    time.sleep(1)
    return n * n

# Первый вызов - медленный
result1 = expensive_function(5)

# Второй вызов - быстрый (из кэша)
result2 = expensive_function(5)
```

---

## 4. Сравнение SQL и NoSQL

| Характеристика | SQL | NoSQL |
|----------------|-----|-------|
| Структура данных | Таблицы с фиксированной схемой | Гибкая структура |
| Масштабирование | Вертикальное (мощный сервер) | Горизонтальное (много серверов) |
| ACID | Полная поддержка | Частичная/отсутствует |
| Запросы | SQL, JOIN'ы | Специфичные для системы |
| Производительность | Высокая для сложных запросов | Высокая для простых операций |
| Согласованность | Строгая | Мягкая/в конечном итоге |

### Когда использовать SQL:
- Четко определенная структура данных
- Необходимость сложных JOIN'ов
- Требования к ACID-транзакциям
- Сложные аналитические запросы
- Мало меняющаяся схема

### Когда использовать NoSQL:
- Непредсказуемая структура данных
- Большие объемы данных
- Высокая нагрузка на чтение/запись
- Необходимость горизонтального масштабирования
- Гибкость в изменении структуры

---

## 5. Выбор технологии хранения

### Факторы выбора:
1. **Объем данных** - сколько данных будет храниться
2. **Тип данных** - структурированные, полуструктурированные, неструктурированные
3. **Частота запросов** - сколько операций чтения/записи в секунду
4. **Тип запросов** - простые или сложные
5. **Требования к согласованности** - строгая или мягкая
6. **Масштабируемость** - текущие и будущие потребности
7. **Бюджет** - стоимость лицензий, оборудования, обслуживания

### Примеры выбора:
- **Магазин электронной коммерции**: SQL для заказов (ACID важен), NoSQL для каталога товаров (гибкость важна)
- **Социальная сеть**: Graph DB для связей между пользователями, Key-Value для сессий
- **Аналитическая платформа**: Columnar DB для аналитики, SQL для отчетов
- **Мобильное приложение**: Document DB для профилей пользователей, CDN для медиафайлов

### Гибридные решения:
- Использование нескольких технологий в одном приложении
- Синхронизация данных между системами
- Использование кэшей для ускорения доступа

### Пример архитектуры:
```
Приложение
├── Redis (кэш)
├── PostgreSQL (пользователи, заказы)
├── MongoDB (профили, настройки)
├── Elasticsearch (поиск)
└── InfluxDB (метрики, логи)
```

### Практические рекомендации:
1. Начинайте с простого решения (часто SQL)
2. Добавляйте NoSQL только при реальной необходимости
3. Используйте кэширование для ускорения
4. Планируйте миграцию данных заранее
5. Тестируйте производительность в условиях, близких к продакшену