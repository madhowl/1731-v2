# Практическое занятие 2: Создание декораторов

## Цель занятия
Научиться создавать и применять различные типы декораторов в Python для расширения функциональности функций и классов.

## Задачи
1. Создать простые декораторы для логирования и измерения времени выполнения
2. Создать декораторы с параметрами
3. Применить встроенные декораторы Python (@staticmethod, @classmethod, @property)
4. Реализовать декоратор для кэширования результатов
5. Создать декоратор для проверки аргументов функции

## Ход работы

### 1. Простые декораторы

Создайте файл `decorators.py` и реализуйте следующие декораторы:

#### Декоратор для логирования

```python
def log_calls(func):
    """
    Декоратор, который логирует вызовы функции
    """
    def wrapper(*args, **kwargs):
        # Выведите сообщение о вызове функции с аргументами
        # Вызовите оригинальную функцию и верните результат
        pass  # Замените на ваш код
    return wrapper

@log_calls
def add_numbers(a, b):
    """Функция сложения двух чисел"""
    return a + b

@log_calls
def greet(name):
    """Функция приветствия"""
    return f"Привет, {name}!"
```

#### Декоратор для измерения времени выполнения

```python
import time

def timing_decorator(func):
    """
    Декоратор, который измеряет время выполнения функции
    """
    def wrapper(*args, **kwargs):
        # Засеките время начала выполнения
        # Вызовите оригинальную функцию
        # Засеките время окончания выполнения
        # Выведите время выполнения
        # Верните результат оригинальной функции
        pass  # Замените на ваш код
    return wrapper

@timing_decorator
def slow_function():
    """Функция, которая имитирует долгое выполнение"""
    time.sleep(1)
    return "Готово!"
```

### 2. Декораторы с параметрами

Создайте декоратор, который повторяет выполнение функции заданное количество раз:

```python
def repeat(times):
    """
    Декоратор, который повторяет выполнение функции заданное количество раз
    
    Args:
        times (int): Количество повторений
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            # Повторите выполнение функции times раз
            # Верните результат последнего выполнения
            pass  # Замените на ваш код
        return wrapper
    return decorator

@repeat(times=3)
def say_hello():
    print("Привет!")

# Вызовите функцию и проверьте, что она выполнится 3 раза
```

Создайте декоратор для ограничения количества попыток выполнения функции:

```python
def retry(max_attempts, exception_type=Exception):
    """
    Декоратор, который повторяет выполнение функции при возникновении исключения
    
    Args:
        max_attempts (int): Максимальное количество попыток
        exception_type (Exception): Тип исключения для повтора
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            # Выполняйте функцию до тех пор, пока не будет успеха или не закончатся попытки
            # При возникновении указанного исключения повторите попытку
            # Если попытки закончились, выбросите последнее исключение
            pass  # Замените на ваш код
        return wrapper
    return decorator

@retry(max_attempts=3)
def unreliable_function():
    import random
    if random.random() < 0.7:
        raise ConnectionError("Ошибка подключения")
    return "Успешно!"
```

### 3. Встроенные декораторы Python

Создайте файл `class_decorators.py` и реализуйте примеры использования встроенных декораторов:

```python
class TemperatureConverter:
    """Класс для конвертации температур"""
    
    def __init__(self, celsius):
        self._celsius = celsius
    
    @property
    def celsius(self):
        """Свойство для получения температуры в Цельсиях"""
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        """Свойство для установки температуры в Цельсиях"""
        if value < -273.15:
            raise ValueError("Температура не может быть ниже абсолютного нуля")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        """Свойство для получения температуры в Фаренгейтах"""
        return self._celsius * 9/5 + 32
    
    @property
    def kelvin(self):
        """Свойство для получения температуры в Кельвинах"""
        return self._celsius + 273.15
    
    @staticmethod
    def fahrenheit_to_celsius(fahrenheit):
        """Статический метод для конвертации Фаренгейтов в Цельсии"""
        return (fahrenheit - 32) * 5/9
    
    @classmethod
    def from_fahrenheit(cls, fahrenheit):
        """Класс-метод для создания объекта из температуры в Фаренгейтах"""
        celsius = cls.fahrenheit_to_celsius(fahrenheit)
        return cls(celsius)

# Пример использования
temp = TemperatureConverter(25)
print(f"Цельсии: {temp.celsius}")
print(f"Фаренгейты: {temp.fahrenheit}")
print(f"Кельвины: {temp.kelvin}")

temp.celsius = 0
print(f"Новая температура: {temp.celsius}")

temp2 = TemperatureConverter.from_fahrenheit(100)
print(f"Температура из Фаренгейтов: {temp2.celsius}")
```

### 4. Декоратор для кэширования

Создайте декоратор, который кэширует результаты выполнения функции:

```python
def cache_decorator(func):
    """
    Декоратор, который кэширует результаты выполнения функции
    """
    cache = {}
    
    def wrapper(*args, **kwargs):
        # Создайте ключ из аргументов
        # Если результат уже в кэше, верните его
        # Иначе вычислите результат, сохраните в кэш и верните
        pass  # Замените на ваш код
    
    return wrapper

@cache_decorator
def fibonacci(n):
    """Функция вычисления чисел Фибоначчи (медленная реализация для демонстрации)"""
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# Протестируйте декоратор
print(fibonacci(10))  # Должно выполниться быстро благодаря кэшированию
```

### 5. Декоратор для проверки аргументов

Создайте декоратор, который проверяет типы аргументов функции:

```python
def type_check(*expected_types):
    """
    Декоратор для проверки типов аргументов функции
    
    Args:
        *expected_types: Ожидаемые типы аргументов
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            # Проверьте, что каждый аргумент соответствует ожидаемому типу
            # Выбросите TypeError с описанием ошибки, если тип не совпадает
            # Если все типы верны, вызовите оригинальную функцию
            pass  # Замените на ваш код
        return wrapper
    return decorator

@type_check(int, int)
def divide(a, b):
    """Функция деления двух чисел"""
    if b == 0:
        raise ValueError("Деление на ноль невозможно")
    return a / b

@type_check(str, int)
def repeat_string(text, count):
    """Функция повторения строки"""
    return text * count

# Протестируйте декораторы
print(divide(10, 2))  # Должно работать
# print(divide(10, "2"))  # Должно выбросить TypeError

print(repeat_string("hi", 3))  # Должно работать
# print(repeat_string(123, 3))  # Должно выбросить TypeError
```

### 6. Комбинирование декораторов

Попробуйте использовать несколько декораторов на одной функции:

```python
@log_calls
@timing_decorator
@cache_decorator
def complex_calculation(x, y):
    """Функция с несколькими декораторами"""
    time.sleep(0.1)  # Имитация сложных вычислений
    return x ** y

# Протестируйте комбинацию декораторов
result1 = complex_calculation(2, 10)
result2 = complex_calculation(2, 10)  # Должно быть быстрее благодаря кэшированию
```

## Требования к выполнению

1. Все декораторы должны корректно передавать аргументы и возвращаемые значения
2. Используйте `functools.wraps` для сохранения метаданных оригинальной функции
3. Обработайте крайние случаи и возможные ошибки
4. Напишите тесты для проверки работы декораторов
5. Документируйте свои декораторы с помощью docstring

## Дополнительные задания

1. Создайте декоратор `@singleton`, который гарантирует, что класс имеет только один экземпляр
2. Реализуйте декоратор `@rate_limit`, который ограничивает частоту вызовов функции
3. Создайте декоратор `@validate`, который проверяет как типы, так и значения аргументов

## Контрольные вопросы

1. Что такое декоратор в Python?
2. Как создать декоратор с параметрами?
3. Какие встроенные декораторы есть в Python?
4. Как работает декоратор `@property`?
5. Почему важно использовать `functools.wraps` в декораторах?
